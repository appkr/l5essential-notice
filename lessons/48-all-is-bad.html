<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

  <meta name="description" content="API에서는 데이터 자체가 사용자에게 제공하는 뷰다. 데이터는 의미를 담고 있어서, 읽기 편하고, 탐색하기 편해야 한다. 블레이드로 HTML 페이지를 꾸몄듯이, 트랜스포머로 API 응답을 포맷팅하는 방법을 배운다."/>
  <meta name="google-site-verification" content="ToXKBimREnz49pDNot4b-N9ZJgYcKXPPsHsjhg4Zzuc"/>
  <meta name="naver-site-verification" content="7cebcc8e5493169f5401870d9ce57f48d18491cd"/>

  <meta name="msapplication-tap-highlight" content="no"/>

  <!-- Facebook Meta -->
  <meta property="og:title" content="라라벨 5 입문 및 실전 / 48강 - all() is bad"/>
  <meta property="og:type" content="Website"/>
  <meta property="og:author" content="appkr (juwonkim@me.com)"/>
  <meta property="og:image" content=""/>

  <!-- Google+ Meta -->
  <meta itemprop="name" content="라라벨 5 입문 및 실전 / 48강 - all() is bad">
  <meta itemprop="description" content="API에서는 데이터 자체가 사용자에게 제공하는 뷰다. 데이터는 의미를 담고 있어서, 읽기 편하고, 탐색하기 편해야 한다. 블레이드로 HTML 페이지를 꾸몄듯이, 트랜스포머로 API 응답을 포맷팅하는 방법을 배운다.">
  <meta itemprop="image" content="">
  <meta itemprop="author" content="appkr (juwonkim@me.com)"/>

  <!-- Twitter Meta -->
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site" content="@appkrs"/>
  <meta name="twitter:title" content="라라벨 5 입문 및 실전 / 48강 - all() is bad"/>
  <meta name="twitter:description" content="API에서는 데이터 자체가 사용자에게 제공하는 뷰다. 데이터는 의미를 담고 있어서, 읽기 편하고, 탐색하기 편해야 한다. 블레이드로 HTML 페이지를 꾸몄듯이, 트랜스포머로 API 응답을 포맷팅하는 방법을 배운다."/>
  <meta name="twitter:image" content=""/>
  <meta name="twitter:domain" content="http://l5.appkr.kr/">

  <!-- Mobile and Rss -->
  <link rel="canonical" href="http://l5.appkr.kr/"/>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700"/>
  <link rel="stylesheet" href="//fonts.googleapis.com/earlyaccess/nanumgothic.css"/>
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons"/>
  <link rel="stylesheet" href="/css/main.css">

  <title>라라벨 5 입문 및 실전 / 48강 - all() is bad</title>

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>
<body id="#app">
  <nav class="navbar navbar-fixed-top role="navigation">

  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="navbar-brand">
        <i class="material-icons">school</i>
        라라벨 5 입문 및 실전
      </a>
    </div>
  </div>
</nav>
  <div class="container">
    <div class="row">
      <aside id="sidebar" class="col-md-3">
        <ul>
                      <li  index="0" current-index="50">
              <a href="/lessons/01-welcome.html">1강 - 처음 만나는 라라벨</a>
            </li>
                      <li  index="1" current-index="50">
              <a href="/lessons/02-hello-laravel.html">2강 - 라라벨 5 설치하기</a>
            </li>
                      <li  index="2" current-index="50">
              <a href="/lessons/02-install-on-windows.html">2강 - 라라벨 5 설치하기 (on Windows)</a>
            </li>
                      <li  index="3" current-index="50">
              <a href="/lessons/03-configuration.html">3강 - 글로벌 설정 살펴보기</a>
            </li>
                      <li  index="4" current-index="50">
              <a href="/lessons/04-routing-basics.html">4강 - Routing 기본기</a>
            </li>
                      <li  index="5" current-index="50">
              <a href="/lessons/05-pass-data-to-view.html">5강 - 뷰에 데이터 바인딩하기</a>
            </li>
                      <li  index="6" current-index="50">
              <a href="/lessons/06-blade-101.html">6강 - 블레이드 101</a>
            </li>
                      <li  index="7" current-index="50">
              <a href="/lessons/07-blade-201.html">7강 - 블레이드 201</a>
            </li>
                      <li  index="8" current-index="50">
              <a href="/lessons/08-raw-queries.html">8강 - 날 쿼리 :(</a>
            </li>
                      <li  index="9" current-index="50">
              <a href="/lessons/09-query-builder.html">9강 - 쿼리 빌더</a>
            </li>
                      <li  index="10" current-index="50">
              <a href="/lessons/10-eloquent.html">10강 - 엘로퀀트 ORM</a>
            </li>
                      <li  index="11" current-index="50">
              <a href="/lessons/11-migration.html">11강 - DB 마이그레이션</a>
            </li>
                      <li  index="12" current-index="50">
              <a href="/lessons/12-controller.html">12강 - 컨트롤러</a>
            </li>
                      <li  index="13" current-index="50">
              <a href="/lessons/13-restful-resource-controller.html">13강 - RESTful 리소스 컨트롤러</a>
            </li>
                      <li  index="14" current-index="50">
              <a href="/lessons/14-named-routes.html">14강 - 이름 있는 Route</a>
            </li>
                      <li  index="15" current-index="50">
              <a href="/lessons/15-nested-resources.html">15강 - 중첩된 리소스</a>
            </li>
                      <li  index="16" current-index="50">
              <a href="/lessons/16-authentication.html">16강 - 사용자 인증 기본기</a>
            </li>
                      <li  index="17" current-index="50">
              <a href="/lessons/17-authentication-201.html">17강 - 라라벨에 내장된 사용자 인증</a>
            </li>
                      <li  index="18" current-index="50">
              <a href="/lessons/18-eloquent-relationships.html">18강 - 모델간 관계 맺기</a>
            </li>
                      <li  index="19" current-index="50">
              <a href="/lessons/19-seeder.html">19강 - 데이터 심기</a>
            </li>
                      <li  index="20" current-index="50">
              <a href="/lessons/20-eager-loading.html">20강 - Eager 로딩</a>
            </li>
                      <li  index="21" current-index="50">
              <a href="/lessons/20-1-pagination.html">추가 - 페이징</a>
            </li>
                      <li  index="22" current-index="50">
              <a href="/lessons/21-mail.html">21강 - 메일 보내기</a>
            </li>
                      <li  index="23" current-index="50">
              <a href="/lessons/22-events.html">22강 - 이벤트</a>
            </li>
                      <li  index="24" current-index="50">
              <a href="/lessons/23-validation.html">23강 - 입력 값 유효성 검사</a>
            </li>
                      <li  index="25" current-index="50">
              <a href="/lessons/24-exception-handling.html">24강 - 예외 처리</a>
            </li>
                      <li  index="26" current-index="50">
              <a href="/lessons/25-composer.html">25강 - 컴포저</a>
            </li>
                      <li  index="27" current-index="50">
              <a href="/lessons/26-document-model.html">26강 - Document 모델</a>
            </li>
                      <li  index="28" current-index="50">
              <a href="/lessons/27-document-controller.html">27강 - Document 컨트롤러</a>
            </li>
                      <li  index="29" current-index="50">
              <a href="/lessons/28-cache.html">28강 - Cache</a>
            </li>
                      <li  index="30" current-index="50">
              <a href="/lessons/29-elixir.html">29강 - Elixir, 만병통치약?</a>
            </li>
                      <li  index="31" current-index="50">
              <a href="/lessons/30-final-touch.html">30강 - Debug &amp; Final Touch</a>
            </li>
                      <li  index="32" current-index="50">
              <a href="/lessons/31-forum-features.html">31강 - 포럼 요구사항 기획</a>
            </li>
                      <li  index="33" current-index="50">
              <a href="/lessons/32-login.html">32강 - 사용자 로그인</a>
            </li>
                      <li  index="34" current-index="50">
              <a href="/lessons/33-social-login.html">33강 - 소셜 로그인</a>
            </li>
                      <li  index="35" current-index="50">
              <a href="/lessons/34-role.html">34강 - 사용자 역할</a>
            </li>
                      <li  index="36" current-index="50">
              <a href="/lessons/35-locale.html">35강 - 다국어 지원</a>
            </li>
                      <li  index="37" current-index="50">
              <a href="/lessons/36-models.html">36강 - 마이그레이션과 모델</a>
            </li>
                      <li  index="38" current-index="50">
              <a href="/lessons/37-articles.html">37강 - Article 기능 구현</a>
            </li>
                      <li  index="39" current-index="50">
              <a href="/lessons/38-tags.html">38강 - Tag 기능 구현</a>
            </li>
                      <li  index="40" current-index="50">
              <a href="/lessons/39-attachments.html">39강 - Attachment 기능 구현</a>
            </li>
                      <li  index="41" current-index="50">
              <a href="/lessons/32n33-auth-refactoring.html">32/33 보충 - 인증 리팩토링</a>
            </li>
                      <li  index="42" current-index="50">
              <a href="/lessons/40-comments.html">40강 - Comment 기능 구현</a>
            </li>
                      <li  index="43" current-index="50">
              <a href="/lessons/41-ui-makeup.html">41강 - UI 개선</a>
            </li>
                      <li  index="44" current-index="50">
              <a href="/lessons/42-be-makeup.html">42강 - 서버 사이드 개선</a>
            </li>
                      <li  index="45" current-index="50">
              <a href="/lessons/43-change-note.html">43강 - 변경 사항 알림</a>
            </li>
                      <li  index="46" current-index="50">
              <a href="/lessons/44-api-basic.html">44강 - API 기본기 및 기획</a>
            </li>
                      <li  index="47" current-index="50">
              <a href="/lessons/45-api-big-picture.html">45강 - 기본 구조 잡기</a>
            </li>
                      <li  index="48" current-index="50">
              <a href="/lessons/46-jwt.html">46강 - JWT 를 이용한 인증</a>
            </li>
                      <li  index="49" current-index="50">
              <a href="/lessons/47-dry-refactoring.html">47강 - 중복 제거 리팩토링</a>
            </li>
                      <li class="active" index="50" current-index="50">
              <a href="/lessons/48-all-is-bad.html">48강 - all() is bad</a>
            </li>
                      <li  index="51" current-index="50">
              <a href="/lessons/49-rate-limit.html">49강 - API Rate Limit</a>
            </li>
                      <li  index="52" current-index="50">
              <a href="/lessons/50-id-obfuscation.html">50강 - 리소스 id 난독화</a>
            </li>
                      <li  index="53" current-index="50">
              <a href="/lessons/51-cors.html">51강 - CORS</a>
            </li>
                      <li  index="54" current-index="50">
              <a href="/lessons/52-caching.html">52강 - Caching</a>
            </li>
                      <li  index="55" current-index="50">
              <a href="/lessons/53-partial-response.html">53강 - Partial Response</a>
            </li>
                      <li  index="56" current-index="50">
              <a href="/lessons/54-api-docs.html">54강 - API Documents</a>
            </li>
                      <li  index="57" current-index="50">
              <a href="/lessons/02-install-homestead-osx.html">Homestead 설치 (on Mac)</a>
            </li>
                      <li  index="58" current-index="50">
              <a href="/lessons/02-install-homestead-windows.html">Homestead 설치 (on Windows)</a>
            </li>
                      <li  index="59" current-index="50">
              <a href="/lessons/999-code-release.html">코드 배포</a>
            </li>
                  </ul>
      </aside>

      <div class="col-md-9">
        <article id="article">
                      <nav id="pagination">
  <ul class="pager pager-top">
    <li class="previous ">
      <a href="/lessons/47-dry-refactoring.html">
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_left</i>
        </span>
        <span class="pager-title">
          47강 - 중복 제거 리...
        </span>
      </a>
    </li>
    <li class="next ">
      <a href="/lessons/49-rate-limit.html">
        <span class="pager-title">
          49강 - API Rate Limi...
        </span>
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_right</i>
        </span>
      </a>
    </li>
  </ul>
</nav>
            <hr/>

            <h1>실전 프로젝트 3 - RESTful API</h1>
<h2>48강 - <code>all()</code> is bad</h2>
<p>앞 강에서 작성한 <code>App\Http\Controllers\Api\V1\ArticlesController::index()</code> 메소드를 살펴 보자.</p>
<pre><code class="language-php">class ArticlesController extends Controller
{
    // ...

    public function index()
    {
        return \App\Article::all();
    }
}</code></pre>
<p><code>all()</code> 이란 메소드를 이용해서, 리소스를 반환 하고 있다. <code>all|get|first\find|...</code> 등의 메소드를 이용하여, 컨트롤러에서 엘로퀀트 모델을 직접 반환하면, 라라벨이 자동으로 Json 으로 캐스팅해 주긴 한다. 그러나, 이렇게 엘로퀀트 모델을 직접 반환하면 다음과 같은 문제가 있다. </p>
<h3>Why <code>all()</code> is bad.</h3>
<ol>
<li>
<p>페이징
가령 레코드가 10만개라고 생각해 보자. 응답 속도는 당연히 느릴 테고, 엄청난 네트워크 대역폭을 사용할 것이다. 그런데, 정작 클라이언트가 필요로 하는 레코드는 단 몇 개라면... 클라이언트가 필요한 데이터가 속한 구간을 탐색해서 사용할 수 있도록 API 에서 Pagination 은 필수이다.</p>
</li>
<li>
<p>추가 데이터를 포함할 수 없다.
엘로퀀트 모델을 그대로 반환한다면, 앞 강에서 보았던 JSON Web Token, HATEOAS 를 위한 링크, 페이지네이션을 위한 정보들을 어떻게 추가할 것인가? 엘로퀀트 모델에서 <a href="https://laravel.com/docs/5.2/eloquent-mutators#accessors-and-mutators">Accessor</a> 를 사용할 수 있지만 한계가 있고, API 응답만 분리하기도 쉽지 않다.</p>
</li>
<li>
<p>API 응답에 DB 의 구조가 그대로 드러난다.
엘로퀀트 모델의 속성 중에는 API 클라이언트에게 필요하지 않은 필드가 있을 수 있다. 또, 클라이언트에게 DB 의 필드 이름이 아닌 다른 필드 이름을 반환하고 싶을 수 도 있다. DB 필드가 그대로 노출되는 것은 보안 측면에서도 좋지 않고, 혹, 나중에 DB 리모데링을 하게 될 경우, 모든 API 클라이언트가 갑자기 동작하지 않고, 변경된 API 로 마이그레이션하는데 오랜 시간이 걸릴 수 있다.</p>
</li>
<li>HTTP 헤더와 응답 코드
엘로퀀트 모델을 그대로 반환하게 되면, 200, 404, 500 3 가지 응답 코드 밖에 쓸 수 없다. 뿐만 아니라, 커스텀 HTTP 헤더를 붙이기도 쉽지 않다.</li>
</ol>
<p>그럼, 어쩌라고? <code>Response::make()</code> 또는 <code>response()</code> Helper 를 이용해서 잘 포맷팅 해서 내 보내야 하는데, 앞 강에서 끌어온 <code>appkr/api</code> 패키지가 그 역할을 해 준다.</p>
<h3>Transformer</h3>
<p>앞 강에서 계속 봤듯이, 컨트롤러에서 뷰를 반환할 때 뷰에 바인딩할 데이터를 모델로 부터 뽑아서 전달한다. 그런데, 뷰에서 모델의 모든 속성 값을 표시하던가? 그리고 필요에 따라서는, 가령 <code>$model-&gt;created_at-&gt;diffForHumans()</code> 처럼 값의 형태를 변경하기여 뷰에 뿌리기도 한 것을 기억할 것이다. </p>
<p>그런데, API 에서는 뷰라는 것이 없다. 우리가 응답하는 JOSN, 즉 데이터 자체가 뷰 (==Presentation Layer) 라고 생각하면 되는데, 여기서도 필요한 데이터만을 표시하거나, 데이터 형태를 변경하는 일이 필요하다. 이 때 필요한 것이 Data Transformer (데이터 변환기) 이다. </p>
<p>Transformer (데이터 변환기) 를 이용함으로써, API 클라이언트에게 전달되는 데이터를 완벽하게 제어할 수 있다. 다시 말하면, 데이터 타입/포맷을 마음대로 변경할 수 있을 뿐더러, 필드를 추가하거나 숨기는 일이 가능해 진다. 앞 절의 3 번에서 언급한 데이터베이스 필드가 바뀌었을 때도, 이 Transformer 가 완충 역할을 할 수 있다. 우리 프로젝트의 <code>Article</code> 모델을 반환할 때, <code>author</code> 관계를 중첩 (Nesting) 하는 등의 조작도 쉬워진다.</p>
<p>Transformer 는 아래 'Simple Trasformer' 의 예처럼 배열을 순회하면서 간단히 구현할 수 있기는 하지만, 지난 강좌에서 가져온 <code>appkr/api</code> 패키지가 의존하는 <code>league/fractal</code> 패키지에서 제공하는 <a href="http://fractal.thephpleague.com/transformers/">Transformer</a> 를 이용할 것이다.</p>
<h4>Simple Transformer</h4>
<p>우리의 실전 프로젝트에서 쓰지는 않을 것이지만, 기본은 이렇다 정도로 알아 두자.</p>
<p><code>Transformer</code> 라는 추상 클래스에 <code>transformCollection()</code>, <code>transform()</code> 등의 메소드를 정의하고 있다. 자세히 보면 <code>transformCollection()</code> 메소드는 인자로 넘겨 받은 <code>$collection</code> 을 <code>array_map()</code> PHP 내장 함수를 이용해서 순회하면서 같은 클래스에 있는 <code>transform()</code> 메소드를 호출하는 것을 볼 수 있다. 그리고, <code>transform()</code> 메소드 자체는 이름만 있고, 내용이 없는 <code>abstract</code> 로 정의되어 있다.</p>
<p><code>ArticleTransformer</code> 는 <code>Transformer</code> 추상 클래스를 상속하고 있기 때문에, 부모 클래스에서 <code>abstract</code> 로 정의한 <code>transform()</code> 메소드를 반드시 구현해야 한다. 여기서, 앞서 언급했던 필요한 필드명을 바꾼다거나, 데이터 타입을 변경하는 등의 작업을 수행한다.</p>
<p><code>ArticlesController::index()</code> 메소드에서 JSON 을 응답할 때, 앞서 구현한 <code>ArticleTransformer::transformCollection()</code> 메소드를 이용하는 것을 볼 수 있다. 모델을 쿼리해서 얻은 엘로퀀트 Collection 을 메소드 인자로 넘기고 있는 것을 확인할 수 있다. 엘로퀀트 Collection 은 PHP 의 ArrayAccess 와 ArrayIterator 를 구현하고 있기에, 배열처럼 순회하면서 우리가 원하는 일들을 할 수 있는 것이다.</p>
<pre><code class="language-php">// Transformer.php

abstract class Transformer
{
    public function transformCollection(\Illuminate\Database\Eloquent\Collection $collection)
    {
        return array_map([$this, 'transform'], $collection);
    }

    public function transformPagination() { /* ... */ }

    public abstract function transform($item);
}</code></pre>
<pre><code class="language-php">// ArticleTransformer.php

class ArticleTransformer extends Transformer
{
    public function transform($article)
    {
        return [
            'id' =&gt; (int) $article-&gt;id,
            // ...
            'created' =&gt; $article-&gt;created_at-&gt;toISO8601String(),
            'author' =&gt; [
                'name' =&gt; $article-&gt;author-&gt;name,
                 // ...
            ],
        ];
    }
}</code></pre>
<pre><code class="language-php">// ArticlesController.php

class ArticlesController extends Controller
{
    public function index()
    {
        return response()-&gt;json([
            'data' =&gt; (new ArticleTransformer)-&gt;transformCollection(App\Article::get())    
        ]);
    }
}</code></pre>
<h4>Advanced Transformer</h4>
<p>이제 이 프로젝트에서 사용할 Transformer 를 artisan CLI 로 만들것이다. CLI 사용법은 <a href="https://github.com/appkr/api"><code>appkr/api</code> 문서</a> 를 참고하자.</p>
<pre><code class="language-bash">$ php artisan make:transformer App\\Article --includes=App\\Comment:comments:true,App\\Author:author,App\\Tag:tags:true,App\\Attachment:attachments:true
$ php artisan make:transformer App\\Comment --includes=App\\Author:authors
$ php artisan make:transformer App\\Tag --includes=App\\Article::articles:true
$ php artisan make:transformer App\\Attachment
$ php artisan make:transformer App\\User --includes=App\\Article:articles:true,App\\Comment:comments:true</code></pre>
<p><code>ArticleTransformer</code> 하나만 살펴 보도록 하자.</p>
<pre><code class="language-php">// app/Transformers/ArticleTransformer.php

&lt;?php

namespace App\Transformers;

use App\Article;
use Appkr\Api\TransformerAbstract;
use League\Fractal\ParamBag;

class ArticleTransformer extends TransformerAbstract
{
    // 클라이언트에서 /v1/articles?include=comments:limit(2|0):order(created_at|desc) 처럼
    // Nesting 된 하위 리소스를 JSON 응답에 포함할 때, 응답할 갯수와 정렬을 정의할 수 있다.
    protected $availableIncludes = ['comments', 'author', 'tags', 'attachments'];

    public function transform(Article $article)
    {
        $payload = [
            'id'           =&gt; (int) $article-&gt;id, // 정수형으로 캐스팅
            'title'        =&gt; $article-&gt;title,
            'content_raw'  =&gt; strip_tags($article-&gt;content), // HTML 태그를 모두 제거 
            'contant_html' =&gt; markdown($article-&gt;content), // 마크다운으로 컴파일
            'created'      =&gt; $article-&gt;created_at-&gt;toIso8601String(),
            'view_count'   =&gt; (int) $article-&gt;view_count,
            'link'         =&gt; [
                'rel'  =&gt; 'self',
                'href' =&gt; route('api.v1.articles.show', $article-&gt;id), // URL
            ],
            'comments'     =&gt; (int) $article-&gt;comments-&gt;count(), // 댓글 수
            'author'       =&gt; sprintf('%s &lt;%s&gt;', $article-&gt;author-&gt;name, $article-&gt;author-&gt;email), 
            'tags'         =&gt; $article-&gt;tags-&gt;pluck('slug'), // ['laravel', 'eloquent', '...']
            'attachments'  =&gt; (int) $article-&gt;attachments-&gt;count(), // 첨부파일 수
        ];

        if ($fields = $this-&gt;getPartialFields()) {
            $payload = array_only($payload, $fields);
        }

        return $payload;
    }

    // $availableIncludes 에 정의된 값들에 대응되는 includeXxx 이름의 메소드를 모두 정의해 주어야 한다.
    // 이 메소드가 있어야 /v1/articles?include=comments 처럼 쿼리스트링을 통해서 하위 리소스를 포함하는 것이 가능해 진다.

    // /v1/articles?include=comments 처럼 QueryString 이 달려 있으면, 
    // config('api.params.limit'), config('api.params.order') 에 정의한 개수와 정렬방식의 Collection 으로 응답된다.
    // Article 와 Comment 의 관계는 morphMany() 로 정의되어 있어, 
    // Article 컨텍스트에서 Comment 는 항상 Collection 이 되어야 한다는 점을 상기하자.
    public function includeComments(Article $article, ParamBag $params = null)
    {
        $transformer = new \App\Transformers\CommentTransformer($params);

        $parsed = $this-&gt;getParsedParams();

        $comments = $article-&gt;comments()-&gt;limit($parsed['limit'])-&gt;offset($parsed['offset'])-&gt;orderBy($parsed['sort'], $parsed['order'])-&gt;get();

        return $this-&gt;collection($comments, $transformer);
    }

    // 얘는 belongsTo() 관계라 Item 을 응답한다.
    // Simple Transformer 구현에서 봤던 내용과 크게 다르지 않다.
    public function includeAuthor(Article $article, ParamBag $params = null)
    {
        return $this-&gt;item($article-&gt;author, new \App\Transformers\UserTransformer($params));
    }

    // 역시 마찬가지. 위에서 Transform 한대로 배열 형태의 Tag Slug 들만 나가지만,
    // ?include=tags 이 있다면 Tag Collection 이 JSON 배열로 반환될 것이다.
    public function includeTags(Article $article, ParamBag $params = null)
    {
        $transformer = new \App\Transformers\TagTransformer($params);

        $parsed = $this-&gt;getParsedParams();

        $tags = $article-&gt;tags()-&gt;limit($parsed['limit'])-&gt;offset($parsed['offset'])-&gt;orderBy($parsed['sort'], $parsed['order'])-&gt;get();

        return $this-&gt;collection($tags, $transformer);
    }

    // Article 과 Attachment 는 hasMany 관계로 연결되어 있기 때문에 Collection 을 응답하는게 맞다. 
    public function includeAttachments(Article $article, ParamBag $params = null)
    {
        $transformer = new \App\Transformers\AttachmentTransformer($params);

        $parsed = $this-&gt;getParsedParams();

        $attachments = $article-&gt;attachments()-&gt;limit($parsed['limit'])-&gt;offset($parsed['offset'])-&gt;orderBy($parsed['sort'], $parsed['order'])-&gt;get();

        return $this-&gt;collection($attachments, $transformer);
    }
}</code></pre>
<h3>Serializer</h3>
<p><code>league/fractal</code> 의 개발자인 Phil Sturgeon 의 포스트 <a href="https://philsturgeon.uk/api/2015/05/30/serializing-api-output/">'The Importance of Serializing API Output'</a> 을 꼭 읽어 보자. </p>
<p>MSDN 정의에 따르면,</p>
<blockquote>
<p>직렬화 (==Serialization) 란 객체를 메모리 데이터베이스, 또는 파일 등에 저장하기 위한 목적으로 바이트 스트림으로 변환하는 행위를 말한다. 직렬화를 하는 이유는, 현재 객체의 상태를 그대로 저장했다가 필요할 때 다시 꺼내 쓰기 위한 목적이다. 반대 개념은 역직렬화 (==Deserialization) 이다.</p>
</blockquote>
<p><img src="https://i-msdn.sec.s-msft.com/dynimg/IC20067.jpeg" alt="" /></p>
<p>가령 객체의 속성이 변경된 상태에서 나중에 이전 상태 그대로 다시 꺼내 쓰고 싶으면 어떻게 할것인가? 객체를 <code>new</code> 키워드로 다시 생성하고, 속성값을 변경해서 사용할 것인가? 아니다, 이때 필요한 것이 직렬화이다. 쉽게 직렬화란 객체를 스트링 형태로 변환해서 저장했다가, 부활시키는 것이라고 보면 된다.</p>
<p>API 에서 직렬화란 Transformer 에서 변경된 모델/데이터의 상태에서의 직렬화를 의미한다. API 에서 직렬화란 위에서 얘기한 상태의 재복원 보다는 데이터를 전달하는 형태에 더 의미를 둔다. (그럼 직렬화가 맞나요? 라고 따지지 말고 그냥 그렇다고 수용하자.) <code>league/fractal</code> 에서도 여러가지 직렬화 방식 (==<a href="http://fractal.thephpleague.com/serializers/">Serializer</a>) 을 지원하는데,</p>
<ul>
<li>
<p><code>ArraySerializer</code>
: Collection 을 응답할 경우에만 <code>data</code> 필드를 사용한다.</p>
</li>
<li>
<p><code>DataArraySerializer</code>
: Item 이든 Collection 이든 무조건 <code>data</code> 필드를 사용한다.</p>
</li>
<li><code>JsonApiSerializer</code>
: <a href="http://jsonapi.org/">JSON API</a> 스펙에 정의된 응답 형식을 따른다. <code>type</code>, <code>id</code>, <code>attributes</code> 란 필드를 필수적으로 사용한다.</li>
</ul>
<p>우리 실전 프로젝트에서는 가장 간단한 <code>ArraySerializer</code> 를 사용할 것이다. <code>config/api.php</code> 에서 원하는 다른 Serializer 로 바꿀 수도 있고, 이미 정의된 Serializer 형식을 넘어서서 자신만의 Custom Serializer 를 만들 수도 있다.</p>
<h3>Controller</h3>
<p>이제 이론을 배웠으니, 우리의 <code>ArticleController</code> 를 변경하자.</p>
<pre><code class="language-php">// app/Http/Controllers/ArticlesController.php

class ArticlesController extends Controller
{
    public function __construct()
    {
        $this-&gt;middleware('author:article', ['only' =&gt; ['update', 'destroy', 'pickBest']]);

        if (! is_api_request()) {
            // \App\Http\Controllers\Api\V1\ArticlesController 에서 이 컨트롤러를 상속할 것이므로,
            // API 에 필요 없는 부분은 (! is_api_request()) 로 제외 시켰다.
            $this-&gt;middleware('auth', ['except' =&gt; ['index', 'show']]);

            $allTags = taggable()
                ? Tag::with('articles')-&gt;remember(5)-&gt;cacheTags('tags')-&gt;get()
                : Tag::with('articles')-&gt;remember(5)-&gt;get();

            view()-&gt;share('allTags', $allTags);
        }

        parent::__construct();
    }

    public function index(FilterArticlesRequest $request, $slug = null)
    {
        // ...

        return $this-&gt;respondCollection($articles);
    }

    public function store(ArticlesRequest $request)
    {
        // ...

        return $this-&gt;respondCreated($article);
    }

    public function show($id)
    {
        // ...

        return $this-&gt;respondItem($article, $commentsCollection);
    }

    public function update(ArticlesRequest $request, $id)
    {
        // ...

        return $this-&gt;respondUpdated($article);
    }

    public function destroy(Request $request, $id)
    {
        // ...

        return $this-&gt;respondDeleted($article);
    }

    // ...

    protected function respondCollection(LengthAwarePaginator $articles)
    {
        return view('articles.index', compact('articles'));
    }

    protected function respondCreated(Article $article)
    {
        flash()-&gt;success(trans('common.created'));

        return redirect(route('articles.index'));
    }

    protected function respondItem(Article $article, Collection $commentsCollection = null)
    {
        return view('articles.show', [
            'article'         =&gt; $article,
            'comments'        =&gt; $commentsCollection,
            'commentableType' =&gt; Article::class,
            'commentableId'   =&gt; $article-&gt;id,
        ]);
    }

    protected function respondUpdated(Article $article)
    {
        flash()-&gt;success(trans('common.updated'));

        return redirect(route('articles.show', $article-&gt;id));
    }

    protected function respondDeleted(Article $article)
    {
        flash()-&gt;success(trans('common.deleted'));

        return redirect(route('articles.index'));
    }
}</code></pre>
<p>앞선 강의에서 언급했다시피, Web Response 랑 API Response 부분은 로직에서 큰 차이가 없다, 다행시 아직까지는... 다만 차이가 나는 부분은 HTML 을 응답하냐?, JSON 을 응답하느냐? 의 차이만 있을 뿐이다. DRY (Don't Repeat Yourself) 원칙에 따라 로직을 최대한 사용하면서, <code>respondCollection()</code>, <code>respondCreated</code>, <code>...</code> 의 응답 메소드만 다르게 정의한 것을 볼 수 있다.</p>
<p>이제 위 클래스의 응답 메소들을 Override 하는 API 응답 메소드들을 만들어 보자. 응답에 사용한 메소드들은 <code>appkr/api</code> 의 <code>Appkr\Api\Http\Response</code> 클래스의 메소드들이다.</p>
<ul>
<li>
<p><code>withPagination(\Illuminate\Pagination\LengthAwarePaginator $paginator, $transformer = null)</code>
인자로 넘겨 받은 <code>Paginator</code> 객체와 <code>Transformer</code> 객체를 이용하여, 페이징이 포함된 JSON 콜렉션을 응답한다.</p>
</li>
<li>
<p><code>withItem(\Illuminate\Pagination\LengthAwarePaginator $paginator, $transformer = null)</code>
역시, 인자로 넘겨 받은 <code>Paginator</code> 객체와 <code>Transformer</code> 객체를 이용하여, 단일 아이템에 대한 JSON 을 응답한다.</p>
</li>
<li>
<p><code>created(\Illuminate\Database\Eloquent\Model|array\String $primitive = 'Created')</code>
201 응답을 반환한다. 엘로퀀트 모델을 받으면 엘로퀀트 모델을 JSON 캐스팅해서 Response Body 에 덧붙이고, 문자열을 넘기면 'config/api.php' 의 <code>successFormat</code> 키에 지정된 형태로 JSON 응답을 한다.  </p>
</li>
<li>
<p><code>success(array|string $message = 'Success')</code>
200 응답을 반환한다. <code>created</code> 와 유사하다.</p>
</li>
<li><code>noContent()</code>
204 응답을 반환한다.</li>
</ul>
<pre><code class="language-php">// app/Http/Controllers/Api/V1/ArticlesController.php

class ArticlesController extends ParentController
{
    public function __construct()
    {
        // 'auth' 대신 'jwt.auth' 미들웨어를 사용하는데, 미들웨어를 적용시키지 않을 메소드는 동일하다.
        // 읽기 요청인 'index' 와 'show' 를 제외했는데, 나중에 Rate Limit 로 시간당 요청 가능 횟수를 제한할 것이다.
        $this-&gt;middleware('jwt.auth', ['except' =&gt; ['index', 'show']]);

        parent::__construct();
    }

    // 부모 클래스를 Override 해서 JSON 응답을 반환한다.
    protected function respondCollection(LengthAwarePaginator $articles)
    {
        return json()-&gt;withPagination($articles, new ArticleTransformer);
    }

    protected function respondCreated(Article $article)
    {
        return json()-&gt;created();
    }

    protected function respondItem(Article $article, Collection $commentsCollection = null)
    {
        return json()-&gt;withItem($article, new ArticleTransformer);
    }

    protected function respondUpdated(Article $article)
    {
        return json()-&gt;success('Updated');
    }

    protected function respondDeleted(Article $article)
    {
        return json()-&gt;noContent();
    }
}</code></pre>
<h3>Test</h3>
<p>어떻게 나오는 지 보자. Article Collection 을 먼저 요청해 본다.</p>
<pre><code class="language-HTTP">GET /v1/articles HTTP/1.1
Host: api.myproject.dev:8000
Accept: application/json</code></pre>
<p><img src="./images/48-all-is-bad-img-01.png" alt="" /></p>
<p>Article 개별 인스턴스를 요청한다. 그런데, 여기서는 <code>?include=comments:limit(2|0):order(id|desc),tags</code> 쿼리스트링을 덧 붙였다. 해석하자면, Comment 를 네스팅하되 0 개를 건너 뛰고 총 2개만, Tag 는 전체 콜렉션을 전부 응답해 달라는 요청이다.</p>
<pre><code class="language-HTTP">GET /v1/articles/1?include=comments:limit(2|0):order(id|desc),tags HTTP/1.1
Host: api.myproject.dev:8000
Accept: application/json</code></pre>
<p><img src="./images/48-all-is-bad-img-02.png" alt="" /></p>
<p>이번에는 Article 을 생성하는 요청을 한다. 먼저 API_DOMAIN/auth/login 을 방문하여 JWT Token 을 얻어서, 이번 테스트 요청의 Authorization 헤더에 붙인다. title, content, tags[] 등의 내용을 입력하고 요청해 보자. 아무 내용 없는 상태로도 요청해 보면, 아마 422 Unprocessable Entity 에 에러가 있는 필드에 대한 설명이 담긴 JSON 응답을 받았을 것이다.</p>
<pre><code class="language-HTTP">POST /v1/articles HTTP/1.1
Host: api.myproject.dev:8000
Accept: application/json
Authorization: bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEsImlzcyI6Imh0dHA6XC9cL2FwaS5teXByb2plY3QuZGV2OjgwMDBcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUyNDM0MjU4LCJleHAiOjE0NTI0NDE0NTgsIm5iZiI6MTQ1MjQzNDI1OCwianRpIjoiNWM4ZjRhOTAxZWQ2YzljYTkxMjQ5NzU2NjVmZTMyODEifQ.bsLX0u5ZvAX2ZD3w1SSSGyhk6tg0F5q_C6nzR2Ez5Tg
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="title"

New Title
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="content"

New Content
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="tags[]"

1
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="tags[]"

5
----WebKitFormBoundary7MA4YWxkTrZu0gW</code></pre>
<p><img src="./images/48-all-is-bad-img-03.png" alt="" /></p>
<p>나머지들은 스스로 테스트해 보자.</p>
<h3>Form Request</h3>
<p><code>App\Http\Controllers\ArticlesController::store()</code> 메소드에서 입력값 유효성 검사를 위해서 <code>App\Http\Requests\ArticlesRequest</code> 라는 <a href="https://laravel.com/docs/5.2/validation#form-request-validation">Form Request</a> 인스턴스를 주입하고 있다 (<a href="37-articles.md">37강 - Article 기능 구현</a>). 그런데, 이 Form Request 는 입력값 유효성 검사에 실패하면 422 JSON 응답을 반환하긴 하지만, 우리가 원하는 모양의 JOSN 포맷이 아니다. <code>App\Http\Requests\ArticlesRequest</code> 의 부모 클래스를 계속 따라가다 적절한 포인트를 찾아서 기존 응답 형식을 우리 형식에 맞도록 메소드 오버라이딩을 해 주자.</p>
<pre><code class="language-php">// app/Http/Requests/Reqeust.php

abstract class Request extends FormRequest
{
    // ...

    public function response(array $errors)
    {
        if (is_api_request()) {
            // API 요청인데, 입력값 유효성 검사에 실패했을 때, 그래서 response() 메소드에 왔을 때는  
            // 부모 클래스인 Illuminate\Foundation\Http\FormRequest::response() 를
            // Override 해서 여기서 바로 JSON 응답을 우리 API 응답 포맷에 맞도록 내 보낸다.
            return json()-&gt;unprocessableError($errors);
        }

        // parent::response() 를 사용하지 않고, 완전히 Overwriting 하였다.
        return $this-&gt;redirector-&gt;to($this-&gt;getRedirectUrl())
            -&gt;withInput($this-&gt;except($this-&gt;dontFlash))
            -&gt;withErrors($errors, $this-&gt;errorBag);
    }

    public function forbiddenResponse()
    {
        if (is_api_request()) {
            // 역시 위와 동일하다.
            return json()-&gt;forbiddenError();
        }

        return response('Forbidden', 403);
    }
}</code></pre>
<h3>Integration Test</h3>
<p>특히 API 의 경우에는 UI 가 없어서 육안 테스트가 번거로울 뿐 아니라, 수정할 일도 많아서 통합 테스트를 작성하는 것이 좋다. 이번 강좌에서 테스트 코드 구현에 대한 내용은 설명하지 않지만, tests 디렉토리 아래에 있는 테스트 코드들을 살펴보도록 하자.</p>
<pre><code class="language-bash">$ phpunit</code></pre>
<p><img src="./images/48-all-is-bad-img-04.png" alt="" /></p>
<p>테스트 코드를 짜는 과정에서 <code>App\Http\Controllers\ArticlesController::update()</code> 동작 관련 몇가지 버그를 잡았다.</p>
<pre><code class="language-php">// app/Http/Requests/ArticlesRequest.php

public function rules()
{
    $rules = [];

    if ($this-&gt;isUpdate()) {
        // update 요청일 때와 아닐 때로 유효성 검사 규칙을 분리했다.
        $rules = ['tags' =&gt; ['array']];
    } else {
        $rules = [
            'title'   =&gt; 'required',
            'content' =&gt; 'required',
            'tags'    =&gt; 'required|array'
        ];
    }

    return $rules;
}</code></pre>
<pre><code class="language-php">// app/Http/Requests/Request.php

protected function isUpdate()
{
    $needle = ['put', 'patch'];

    return in_array(strtolower($this-&gt;input('_method')), $needle)
        or in_array(strtolower($this-&gt;header('x-http-method-override')), $needle)
        // _method=PUT 등으로 메소드 오버로딩을 하지 않아도 되는 클라이언트를 위해 아래 한줄을 보강했다.
        or in_array(strtolower($this-&gt;method()), $needle);
}</code></pre>
<pre><code class="language-php">// app/Http/Controllers/ArticlesController.php

public function update(ArticlesRequest $request, $id)
{
    // If Check 가 추가되었다. tags 필드를 넘기지 않으면 에러가 나므로...
    if ($request-&gt;has('tags')) {
        $article-&gt;tags()-&gt;sync($request-&gt;input('tags'));
    }
    // ...
}</code></pre>
<p>또, Article 모델에 접근제한하는 부분에서도, API 요청일 경우에 적절한 JSON 응답을 하도록 고쳤다.</p>
<pre><code class="language-php">// app/Http/Middleware/AuthorOnly.php

public function handle(Request $request, Closure $next, $param)
{
    //...
    if (! $model::whereId($modelId)-&gt;whereAuthorId($user-&gt;id)-&gt;exists() and ! $user-&gt;isAdmin()) {
        if (is_api_request()) {
            return json()-&gt;forbiddenError();
        }

        return back();
    }

    return $next($request);
}</code></pre>
<!--@start-->
<hr />
<ul>
<li><a href="../readme.md">목록으로 돌아가기</a></li>
<li><a href="47-dry-refactoring.md">47강 - 중복 제거 리팩토링</a></li>
<li><a href="49-rate-limit.md">49강 - API Rate Limit</a>
<!--@end--></li>
</ul>

            <hr/>

            <nav id="pagination">
  <ul class="pager pager-bottom">
    <li class="previous ">
      <a href="/lessons/47-dry-refactoring.html">
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_left</i>
        </span>
        <span class="pager-title">
          47강 - 중복 제거 리...
        </span>
      </a>
    </li>
    <li class="next ">
      <a href="/lessons/49-rate-limit.html">
        <span class="pager-title">
          49강 - API Rate Limi...
        </span>
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_right</i>
        </span>
      </a>
    </li>
  </ul>
</nav>                  </article>

        <hr class="divider">

        <div id="comment">
          <div class="comments" style="margin-bottom: 30px;">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//l5lessons.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  <!--script id="dsq-count-scr" src="//l5lessons.disqus.com/count.js" async></script-->
</div>        </div>
      </div>
    </div>
  </div>

  <div id="toggler">
    <a href="#" title="Open Menu">
      목록 토글
    </a>
  </div>

  <footer id="footer">
  <div>
    &copy; 2016 &nbsp; <a href="https://github.com/appkr">appkr</a> •
    Built with <a href="http://jigsaw.tighten.co/">Jigsaw</a> •
    Hosted by <a href="https://pages.github.com/">Github</a> •
    <a href="/feed.xml">Rss</a>
  </div>
</footer>

<div id="back-to-top">
  <a href="#" title="Scroll to Top">
    <i class="material-icons">keyboard_arrow_up</i>
  </a>
</div>
  <script src="/js/all.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-71112324-1', 'auto');
    ga('send', 'pageview');
  </script>
</body>
</html>

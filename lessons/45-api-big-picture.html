<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

  <meta name="description" content="API는 별도의 URL 엔드포인트와 컨트롤러를 사용한다. 그럼에도 불구하고, 웹 브라우저에서 들어 오는 요청과 처리 로직이 달라질 것이 없으므로, 컨트롤러를 최대한 재활용하고 중복을 제거하는 구조를 같이 고민해 본다."/>
  <meta name="google-site-verification" content="ToXKBimREnz49pDNot4b-N9ZJgYcKXPPsHsjhg4Zzuc"/>
  <meta name="naver-site-verification" content="7cebcc8e5493169f5401870d9ce57f48d18491cd"/>

  <meta name="msapplication-tap-highlight" content="no"/>

  <!-- Facebook Meta -->
  <meta property="og:title" content="라라벨 5 입문 및 실전 / 45강 - 기본 구조 잡기"/>
  <meta property="og:type" content="Website"/>
  <meta property="og:author" content="appkr (juwonkim@me.com)"/>
  <meta property="og:image" content=""/>

  <!-- Google+ Meta -->
  <meta itemprop="name" content="라라벨 5 입문 및 실전 / 45강 - 기본 구조 잡기">
  <meta itemprop="description" content="API는 별도의 URL 엔드포인트와 컨트롤러를 사용한다. 그럼에도 불구하고, 웹 브라우저에서 들어 오는 요청과 처리 로직이 달라질 것이 없으므로, 컨트롤러를 최대한 재활용하고 중복을 제거하는 구조를 같이 고민해 본다.">
  <meta itemprop="image" content="">
  <meta itemprop="author" content="appkr (juwonkim@me.com)"/>

  <!-- Twitter Meta -->
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site" content="@appkrs"/>
  <meta name="twitter:title" content="라라벨 5 입문 및 실전 / 45강 - 기본 구조 잡기"/>
  <meta name="twitter:description" content="API는 별도의 URL 엔드포인트와 컨트롤러를 사용한다. 그럼에도 불구하고, 웹 브라우저에서 들어 오는 요청과 처리 로직이 달라질 것이 없으므로, 컨트롤러를 최대한 재활용하고 중복을 제거하는 구조를 같이 고민해 본다."/>
  <meta name="twitter:image" content=""/>
  <meta name="twitter:domain" content="http://l5.appkr.kr/">

  <!-- Mobile and Rss -->
  <link rel="canonical" href="http://l5.appkr.kr/"/>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700"/>
  <link rel="stylesheet" href="//fonts.googleapis.com/earlyaccess/nanumgothic.css"/>
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons"/>
  <link rel="stylesheet" href="/css/main.css">

  <title>라라벨 5 입문 및 실전 / 45강 - 기본 구조 잡기</title>

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>
<body id="#app">
  <nav class="navbar navbar-fixed-top role="navigation">

  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="navbar-brand">
        <i class="material-icons">school</i>
        라라벨 5 입문 및 실전
      </a>
    </div>
  </div>
</nav>
  <div class="container">
    <div class="row">
      <aside id="sidebar" class="col-md-3">
        <ul>
                      <li  index="0" current-index="47">
              <a href="/lessons/01-welcome.html">1강 - 처음 만나는 라라벨</a>
            </li>
                      <li  index="1" current-index="47">
              <a href="/lessons/02-hello-laravel.html">2강 - 라라벨 5 설치하기</a>
            </li>
                      <li  index="2" current-index="47">
              <a href="/lessons/02-install-on-windows.html">2강 - 라라벨 5 설치하기 (on Windows)</a>
            </li>
                      <li  index="3" current-index="47">
              <a href="/lessons/03-configuration.html">3강 - 글로벌 설정 살펴보기</a>
            </li>
                      <li  index="4" current-index="47">
              <a href="/lessons/04-routing-basics.html">4강 - Routing 기본기</a>
            </li>
                      <li  index="5" current-index="47">
              <a href="/lessons/05-pass-data-to-view.html">5강 - 뷰에 데이터 바인딩하기</a>
            </li>
                      <li  index="6" current-index="47">
              <a href="/lessons/06-blade-101.html">6강 - 블레이드 101</a>
            </li>
                      <li  index="7" current-index="47">
              <a href="/lessons/07-blade-201.html">7강 - 블레이드 201</a>
            </li>
                      <li  index="8" current-index="47">
              <a href="/lessons/08-raw-queries.html">8강 - 날 쿼리 :(</a>
            </li>
                      <li  index="9" current-index="47">
              <a href="/lessons/09-query-builder.html">9강 - 쿼리 빌더</a>
            </li>
                      <li  index="10" current-index="47">
              <a href="/lessons/10-eloquent.html">10강 - 엘로퀀트 ORM</a>
            </li>
                      <li  index="11" current-index="47">
              <a href="/lessons/11-migration.html">11강 - DB 마이그레이션</a>
            </li>
                      <li  index="12" current-index="47">
              <a href="/lessons/12-controller.html">12강 - 컨트롤러</a>
            </li>
                      <li  index="13" current-index="47">
              <a href="/lessons/13-restful-resource-controller.html">13강 - RESTful 리소스 컨트롤러</a>
            </li>
                      <li  index="14" current-index="47">
              <a href="/lessons/14-named-routes.html">14강 - 이름 있는 Route</a>
            </li>
                      <li  index="15" current-index="47">
              <a href="/lessons/15-nested-resources.html">15강 - 중첩된 리소스</a>
            </li>
                      <li  index="16" current-index="47">
              <a href="/lessons/16-authentication.html">16강 - 사용자 인증 기본기</a>
            </li>
                      <li  index="17" current-index="47">
              <a href="/lessons/17-authentication-201.html">17강 - 라라벨에 내장된 사용자 인증</a>
            </li>
                      <li  index="18" current-index="47">
              <a href="/lessons/18-eloquent-relationships.html">18강 - 모델간 관계 맺기</a>
            </li>
                      <li  index="19" current-index="47">
              <a href="/lessons/19-seeder.html">19강 - 데이터 심기</a>
            </li>
                      <li  index="20" current-index="47">
              <a href="/lessons/20-eager-loading.html">20강 - Eager 로딩</a>
            </li>
                      <li  index="21" current-index="47">
              <a href="/lessons/20-1-pagination.html">추가 - 페이징</a>
            </li>
                      <li  index="22" current-index="47">
              <a href="/lessons/21-mail.html">21강 - 메일 보내기</a>
            </li>
                      <li  index="23" current-index="47">
              <a href="/lessons/22-events.html">22강 - 이벤트</a>
            </li>
                      <li  index="24" current-index="47">
              <a href="/lessons/23-validation.html">23강 - 입력 값 유효성 검사</a>
            </li>
                      <li  index="25" current-index="47">
              <a href="/lessons/24-exception-handling.html">24강 - 예외 처리</a>
            </li>
                      <li  index="26" current-index="47">
              <a href="/lessons/25-composer.html">25강 - 컴포저</a>
            </li>
                      <li  index="27" current-index="47">
              <a href="/lessons/26-document-model.html">26강 - Document 모델</a>
            </li>
                      <li  index="28" current-index="47">
              <a href="/lessons/27-document-controller.html">27강 - Document 컨트롤러</a>
            </li>
                      <li  index="29" current-index="47">
              <a href="/lessons/28-cache.html">28강 - Cache</a>
            </li>
                      <li  index="30" current-index="47">
              <a href="/lessons/29-elixir.html">29강 - Elixir, 만병통치약?</a>
            </li>
                      <li  index="31" current-index="47">
              <a href="/lessons/30-final-touch.html">30강 - Debug &amp; Final Touch</a>
            </li>
                      <li  index="32" current-index="47">
              <a href="/lessons/31-forum-features.html">31강 - 포럼 요구사항 기획</a>
            </li>
                      <li  index="33" current-index="47">
              <a href="/lessons/32-login.html">32강 - 사용자 로그인</a>
            </li>
                      <li  index="34" current-index="47">
              <a href="/lessons/33-social-login.html">33강 - 소셜 로그인</a>
            </li>
                      <li  index="35" current-index="47">
              <a href="/lessons/34-role.html">34강 - 사용자 역할</a>
            </li>
                      <li  index="36" current-index="47">
              <a href="/lessons/35-locale.html">35강 - 다국어 지원</a>
            </li>
                      <li  index="37" current-index="47">
              <a href="/lessons/36-models.html">36강 - 마이그레이션과 모델</a>
            </li>
                      <li  index="38" current-index="47">
              <a href="/lessons/37-articles.html">37강 - Article 기능 구현</a>
            </li>
                      <li  index="39" current-index="47">
              <a href="/lessons/38-tags.html">38강 - Tag 기능 구현</a>
            </li>
                      <li  index="40" current-index="47">
              <a href="/lessons/39-attachments.html">39강 - Attachment 기능 구현</a>
            </li>
                      <li  index="41" current-index="47">
              <a href="/lessons/32n33-auth-refactoring.html">32/33 보충 - 인증 리팩토링</a>
            </li>
                      <li  index="42" current-index="47">
              <a href="/lessons/40-comments.html">40강 - Comment 기능 구현</a>
            </li>
                      <li  index="43" current-index="47">
              <a href="/lessons/41-ui-makeup.html">41강 - UI 개선</a>
            </li>
                      <li  index="44" current-index="47">
              <a href="/lessons/42-be-makeup.html">42강 - 서버 사이드 개선</a>
            </li>
                      <li  index="45" current-index="47">
              <a href="/lessons/43-change-note.html">43강 - 변경 사항 알림</a>
            </li>
                      <li  index="46" current-index="47">
              <a href="/lessons/44-api-basic.html">44강 - API 기본기 및 기획</a>
            </li>
                      <li class="active" index="47" current-index="47">
              <a href="/lessons/45-api-big-picture.html">45강 - 기본 구조 잡기</a>
            </li>
                      <li  index="48" current-index="47">
              <a href="/lessons/46-jwt.html">46강 - JWT 를 이용한 인증</a>
            </li>
                      <li  index="49" current-index="47">
              <a href="/lessons/47-dry-refactoring.html">47강 - 중복 제거 리팩토링</a>
            </li>
                      <li  index="50" current-index="47">
              <a href="/lessons/48-all-is-bad.html">48강 - all() is bad</a>
            </li>
                      <li  index="51" current-index="47">
              <a href="/lessons/49-rate-limit.html">49강 - API Rate Limit</a>
            </li>
                      <li  index="52" current-index="47">
              <a href="/lessons/50-id-obfuscation.html">50강 - 리소스 id 난독화</a>
            </li>
                      <li  index="53" current-index="47">
              <a href="/lessons/51-cors.html">51강 - CORS</a>
            </li>
                      <li  index="54" current-index="47">
              <a href="/lessons/52-caching.html">52강 - Caching</a>
            </li>
                      <li  index="55" current-index="47">
              <a href="/lessons/53-partial-response.html">53강 - Partial Response</a>
            </li>
                      <li  index="56" current-index="47">
              <a href="/lessons/54-api-docs.html">54강 - API Documents</a>
            </li>
                      <li  index="57" current-index="47">
              <a href="/lessons/02-install-homestead-osx.html">Homestead 설치 (on Mac)</a>
            </li>
                      <li  index="58" current-index="47">
              <a href="/lessons/02-install-homestead-windows.html">Homestead 설치 (on Windows)</a>
            </li>
                      <li  index="59" current-index="47">
              <a href="/lessons/999-code-release.html">코드 배포</a>
            </li>
                  </ul>
      </aside>

      <div class="col-md-9">
        <article id="article">
                      <nav id="pagination">
  <ul class="pager pager-top">
    <li class="previous ">
      <a href="/lessons/44-api-basic.html">
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_left</i>
        </span>
        <span class="pager-title">
          44강 - API 기본기 및...
        </span>
      </a>
    </li>
    <li class="next ">
      <a href="/lessons/46-jwt.html">
        <span class="pager-title">
          46강 - JWT 를 이용한...
        </span>
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_right</i>
        </span>
      </a>
    </li>
  </ul>
</nav>
            <hr/>

            <h1>실전 프로젝트 3 - RESTful API</h1>
<h2>45강 - 기본 구조 잡기</h2>
<p>앞 강좌에서 기획한 내용을 가장 잘 수용할 수 있는 기본 구조를 잡아보자. 한 방에 완벽할 수는 없기에, 진행하면서 구조는 변경될 수도 있음을 감안하자.</p>
<h3>단일 서버 vs. 복수 서버</h3>
<p>대형 서비스의 경우, API 를 위해 물리적으로 분리된 별도의 서버를 두고, 데이터베이스를 공유하는 식의 아키텍처를 사용하기도 한다. 예를 들면, 서버 A 에 HTML 뷰와 RedirectResponse 를 응답하는 라라벨 어플리케이션을 구동하고, 서버 B 에 API 요청에 응답하는 라라벨 어플리케이션을 두는 식이다. 이 구조에서는 데이터 무결성 확보 등 신경 쓸 일이 굉장히 많아진다.</p>
<p>이 실전 프로젝트에서는 단일 서버, 단일 라라벨 프레임웍을 사용하되, API 를 위한 엔트포인트만 별도의 도메인인 <code>api.myproject.dev</code> 로 분리하도록 하자. </p>
<h3>도메인 설정</h3>
<p>앞서 얘기했듯이 <code>myproject.dev</code> 와 <code>api.myproject.dev</code> 란 도메인을 만들어 보자. 실제로 도메인 서비스에 등록하는 것은 아니고, 로컬에서 'hosts' 파일을 변경하도록 하자. </p>
<p><strong><code>참고</code></strong> 운영체제에 포함된 'hosts' 파일은 DNS 로 api.myproject.dev 또는 myproject.dev 에 대한 ip 주소 Resolution 요청이 나가기 전에 요청을 낚아 채서, 'hosts' 파일 안에서 찾는다. 사용자가 요청한 도메인에 해당하는 레코드가 있으면 지정된 ip 주소로 이동할 것이다. 쓸데 없는 얘기긴한데... 보통 인터넷을 통해 라이센스 인증을 받는 상용소프트웨어의 경우, 이 hosts 파일을 이용해서 인증 서버에 해당하는 도메인을 로컬 주소로 바꾸고, 로컬 서버에서 인증된 것 처럼 꾸며 어둠의 소프트웨어를 사용할 수 있게 한다.</p>
<pre><code class="language-bash"># Mac/Linux
$ sudo nano /etc/hosts

# Windows (코맨드프롬프트를 관리자 권한으로 실행해야 한다.)
\&gt; notepad %SystemRoot%\System32\drivers\etc\hosts</code></pre>
<pre><code class="language-bash"># /etc/hosts

127.0.0.1   myproject.dev
127.0.0.1   api.myproject.dev

# ctrl + x, Y, Enter 순으로 변경 내용 저장
# Homestead 를 쓰신다면, 192.168.10.10 으로 해 주어야 한다.</code></pre>
<p>로컬 서버를 띄울 때, 이전과는 명령이 달라졌으니 잘 기억해 두자. 어떻게 알았냐고? <code>$ php artisan help serve</code>.</p>
<pre><code class="language-bash">$ php artisan serve --host=myproject.dev</code></pre>
<p>브라우저를 열고 '<a href="http://myproject.dev:8000">http://myproject.dev:8000</a>' 으로 접근해서 앞 강좌에서 개발한 페이지가 보이는 지 확인하자.</p>
<h3>Routing</h3>
<p>도메인이 만들어 졌으니 신나게 Routing 을 정의해 보자. <code>Route::group()</code> 의 첫번째 배열 인자 안에 <code>domain</code>, <code>namespace</code>, <code>as</code> 를 썼다. <code>domain</code> 에 매칭되는 요청이 들어오면 이 Routing 블럭이 응답하게 된다. <code>Route::group()</code> 내부에서 컨트롤러를 연결시킬 때 매번 <code>'Api\WelcomeController@index'</code> 식으로 네임스페이스를 붙여주어야 하는 번거로움을 덜기 위해, <code>namespace</code> 라는 키워드를 사용한다. <code>'as' =&gt; 'api.'</code> 은 Route 이름 앞에 'api.' 을 붙이기 위해 사용하였다.</p>
<p>도메인 이름을 '.env' 파일의 <code>API_DOMAIN</code> 값으로 지정했는데, 이는 프로덕션으로 배포할 때마다 Route 파일을 고쳐서 배포해야 하는 번거로움을 피하기 위해서다.</p>
<p><code>Route::group()</code> 안에 또 다른 <code>Route::group()</code> 이 중첩되어 있다. 두번 째 <code>Route::group()</code> 은 '<a href="http://api.myproject.dev:8000/v1">http://api.myproject.dev:8000/v1</a>' 요청에 응답하기 위한 것이다. 그래서 <code>'prefix' =&gt; 'v1'</code>, <code>'namespace' =&gt; 'V1'</code> 을 정의하고 있다.</p>
<pre><code class="language-php">// app/Http/routes.php

Route::group(['domain' =&gt; env('API_DOMAIN'), 'as' =&gt; 'api.', namespace' =&gt; 'Api'], function() {
    Route::get('/', [
        'as'   =&gt; 'index',
        'uses' =&gt; 'WelcomeController@index'
    ]);

    Route::group(['prefix' =&gt; 'v1', 'namespace' =&gt; 'V1'], function() {
        /* Landing page */
        Route::get('/', [
            'as'   =&gt; 'v1.index',
            'uses' =&gt; 'WelcomeController@index'
        ]);
    ]);
}

// 기존 Routing ...
Route::group(['domain' =&gt; env('APP_DOMAIN')], function() {
    Route::get('/', [
        'as'   =&gt; 'index',
        'uses' =&gt; 'WelcomeController@index',
    ]);
});</code></pre>
<p>사용자 인증을 위한 Routing 들인, 'auth/register', 'auth/login', 'auth/remind' 들도 정의하도록 하자. 유의할 점은 API 클라이언트와 데이터만으로 통신을 하기 때문에, 뷰를 반환하는 Route 는 필요없다는 점이다. 그리고, 비밀번호 초기화 기능에서는 사용자의 이메일 주소를 받아서 Reset 토큰을 메일로 보내는 Route 만 제공하고, 그 이후 프로세스는 API 클라이언트와 분리된 메일 클라이언트에서 이루어 지므로 Route 를 제외 했다.</p>
<h3>컨트롤러</h3>
<p>앞 절에서 봤듯이 <code>Api</code> 란 네임스페이스를 이용하고 있다. 'app/Http/Controllers/Api' 디렉토리를 만들자. 방금 만든 디렉토리에 기존에 만들었던 'WelcomeController.php' 를 복사하고 아래와 같이 내용을 변경하자.</p>
<p>'/v1' 요청에 응답하기 위한 'WelcomeController.php' 도, 아래 내용을 참고해서 'app/Http/Controllers/Api/V1' 디렉토리 아래에 만들도록 하자.</p>
<pre><code class="language-php">// app/Http/Controllers/Api/WelcomeController.php

&lt;?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;

class WelcomeController extends Controller
{
    public function index()
    {
        return response()-&gt;json([
            'name'    =&gt; 'myProject Api',
            'message' =&gt; 'Welcome to myProject Api. This is a base endpoint.',
            'version' =&gt; 'n/a',
            'links'   =&gt; [
                [
                    'rel'  =&gt; 'self',
                    'href' =&gt; route(\Route::currentRouteName())
                ],
                [
                    'rel'  =&gt; 'api.v1.index',
                    'href' =&gt; route('api.v1.index')
                ],
            ],
        ]);
    }
}</code></pre>
<p>브라우저로 테스트를 해도 되는데, API 이니까 <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop">PostMan 크롬 확장 프로그램</a> 을 이용하자. 'GET <a href="http://api.myproject.dev:8000">http://api.myproject.dev:8000</a>' 요청을 해 보자. 현재 컨트롤러는 무조건 JSON 만 응답하기 때문에 <code>Accept</code> HTTP Header 는 필요없지만, 좋은 습관이니 <code>application/json</code> 으로 지정하도록 하자. </p>
<p><img src="./images/45-api-big-picture-img-01.png" alt="" /></p>
<h3>DRY 구조 설계</h3>
<p>DRY (==Don't Repeat Yourself) 는 코드의 재사용을 의미한다. </p>
<p>우리는 기존에 개발한 컨트롤러들을 재활용할 것이다. 잘 생각해 보면, 기존에 개발한 컨트롤러 로직에서 API 서비스를 위해 변경되어야 하는 부분은 HTTP 응답 부분 뿐이다. 기존 컨트롤러에서는 뷰 (<code>\Illuminate\Contracts\View\Factory</code>) 또는 Redirect (<code>\Illuminate\Http\RedirectResponse</code>) 를 응답했다면, API 컨트롤러들에서는 JSON 응답 (<code>\Illuminate\Http\JsonResponse</code>) 을 반환하는 부분만 달라진다. 그래서, 기존 컨트롤러에서 뷰 또는 Redirect 를 응답하는 부분을 별도 메소드로 빼내고, API 컨트롤러들은 기존 컨트롤러를 일대일로 상속받되, 방금 추출한 응답 메소드만 오버라이드하면 깔끔할 것 같다. </p>
<p><strong><code>참고</code></strong> PHP 에서는 오버로딩을 지원하지 않는다. 오버로딩은 부모 메소드와 같은 이름을 가지지만, 인자도 다를 수 있고 내부에서 완전히 다른 동작을 하고 완전히 다른 결과를 반환하는 반면, 오버라이드는 인자의 타입과 갯수가 부모와 정확히 같아야 하고, 내부의 동작만 다른 것을 의미한다. 대신 PHP에서는 반환값에 대한 타입 정의가 없어서 부모를 오버라이드한 자식 클래스의 메소드에서 반환값의 타입을 다르게 쓸 수 있다. (PHP 7에서는 부모 클래스에 반환값 타입이 선언되어 있으면, 자식 클래스에서 반환값 타입을 오버로딩을 할 수 없다.)</p>
<h4>abstract 컨트롤러</h4>
<p>기존 컨트롤러들이 상속을 받고 있는 abstract 컨트롤러인 <code>App\Http\Controllers\Controller</code> 에서 뷰에 공용 변수를 셋팅하는 부분은 Api 컨트롤러에서는 필요 없다.</p>
<pre><code class="language-php">// app/Http/Controllers/Controller.php

abstract class Controller extends BaseController
{
    public function __construct() {
        if (! is_api_request()) {
            $this-&gt;setSharedVariables();
        }
    }

    // ...
}</code></pre>
<p><code>is_api_request()</code> 란 Helper 는 쓰일 일이 많을 것 같아서 만들었다.</p>
<pre><code class="language-php">// app/helpers.php

function is_api_request()
{
    return starts_with(Request::getHttpHost(), env('API_DOMAIN'));
}</code></pre>
<h4>기존 컨트롤러 리팩토링</h4>
<p>기존 컨트롤러에서 뷰 또는 Redirect 를 응답하는 부분을 메소드로 추출 (==Extract) 해 내자. 'routes.php' 에 정의한 대로 오늘 강좌의 대상이 되는 컨트롤러는 <code>UsersController</code>, <code>SessionsController</code>, <code>PasswordsController</code> 등이다. 몇 개만 같이 살펴보고, 나머지는 코드를 참조하기 바란다.</p>
<pre><code class="language-php">// app/Http/Controllers/UsersController.php

namespace App\Http\Controllers;

class UsersController extends Controller
{
    protected function syncAccountInfo(Request $request, User $user)
    {
        // ...

        if ($validator-&gt;fails()) {
            return $this-&gt;respondValidationError($validator);
        }

        // ...

        return $this-&gt;respondCreated($user);
    }

    protected function respondValidationError(Validator $validator)
    {
        return back()-&gt;withInput()-&gt;withErrors($validator);
    }

    protected function respondCreated(User $user)
    {
        \Auth::login($user);
        flash(trans('auth.welcome', ['name' =&gt; $user-&gt;name]));

        return redirect(route('home'));
    }
}</code></pre>
<pre><code class="language-php">// app/Http/Controllers/Api/UsersController.php

namespace App\Http\Controllers\Api;

class UsersController extends ParentController
{
    protected function respondValidationError(Validator $validator)
    {
        return response()-&gt;json([
            'code' =&gt; 422,
            'errors' =&gt; $validator-&gt;errors()-&gt;all()
        ], 422);
    }

    protected function respondCreated(User $user)
    {
        // Todo 로그인 하는 대신 JSON Web Token 을 응답할 것이다.
        return response()-&gt;json([
            'code' =&gt; 201,
            'message' =&gt; 'success',
            'token' =&gt; 'token here',
        ], 201);
    }
}</code></pre>
<p><img src="./images/45-api-big-picture-img-02.png" alt="" /></p>
<p>대충 감이 잡히는가? 하나만 더 살펴 보자.</p>
<pre><code class="language-php">// app/Http/Controllers/SessionsController.php

namespace App\Http\Controllers;

class SessionsController extends Controller
{
    public function store(Request $request)
    {
        // ...

        if ($validator-&gt;fails()) {
            return $this-&gt;respondValidationError($validator);
        }

        // API 에서는 쿠키를 이용한 세션 유지 (로그인)을 하지 않기에
        // attempt() 메소드를 쓰지 않고 once() 메소드를 이용하였다.
        // Auth::once() 는 JWT 인증으로 대체될 것이다.
        $valid = is_api_request()
            ? Auth::once($request-&gt;only('email', 'password'))
            : Auth::attempt($request-&gt;only('email', 'password'), $request-&gt;has('remember'));

        if (! $valid) {
            return $this-&gt;respondLoginFailed();
        }

        event('users.login', [Auth::user()]);

        return $this-&gt;respondCreated($request-&gt;input('return'));
    }

    // ...

    protected function respondValidationError(Validator $validator)
    {
        return back()-&gt;withInput()-&gt;withErrors($validator);
    }

    protected function respondLoginFailed()
    {
        flash()-&gt;error(trans('auth.failed'));

        return back()-&gt;withInput();
    }

    protected function respondCreated($return = '')
    {
        flash(trans('auth.welcome', ['name' =&gt; Auth::user()-&gt;name]));

        return ($return) ? redirect(urldecode($return)) : redirect()-&gt;intended();
    }
}</code></pre>
<pre><code class="language-php">// app/Http/Controllers/Api/SessionsController.php

namespace App\Http\Controllers\Api;

class SessionsController extends ParentController
{
    protected function respondValidationError(Validator $validator)
    {
        return response()-&gt;json([
            'code' =&gt; 422,
            'errors' =&gt; $validator-&gt;errors()-&gt;all()
        ], 422);
    }

    protected function respondLoginFailed()
    {
        return response()-&gt;json([
            'code' =&gt; 401,
            'errors' =&gt; 'invalid_credentials'
        ], 401);
    }

    protected function respondCreated($return = '')
    {
        // Todo 로그인 하는 대신 JSON Web Token 을 응답할 것이다.
        return response()-&gt;json([
            'code' =&gt; 201,
            'message' =&gt; 'success',
            'token' =&gt; 'token here',
        ], 201);
    }
}</code></pre>
<p>대충 보기에도, <code>respondValidationError()</code>, <code>respondCreated()</code> 등등 엄청난 중복이 보인다. 앞으로 진행될 강좌에서 중복들은 제거할 것이다. </p>
<p><strong><code>참고</code></strong> API 클라이언트에서 소셜 로그인은 각 클라이언트 플랫폼에 맞는 SDK 를 이용해야 한다. 가령, Android 에서 Github 로그인을 지원한다면 <a href="https://github.com/wuman/android-oauth-client"><code>wuman/android-oauth-client</code></a> 와 같은 라이브러리를 이용하여 소셜 로그인을 구현한다. 그런데, Github 에서 받은 Oauth access_token 으로 Github 리소스에 접근하는 것이 아니다. 즉, 소셜 로그인은 소위 말하는 실명 확인 정도, 사용자 등록에 대한 거부감을 좀 덜어 주는 정도의 용도로만 사용하고 있다. 우리 서버의 리소스에 접근하기 위해서는 우리 서버에서 클라이언트 요청의 유효성을 인증 받을 수 있는 방법이 있어야 한다. Android Native SDK 를 이용한 소셜 인증은 받되, 가령 <code>onSuccess</code> Callback 을 받는 부분에서 서버와 인터랙션을 해야 할 것으로 생각된다. 어쩌면, 서버 측에서 이를 위한 새로운 Route 를 제공해야 할 수도 있을 것 같다. 진행하면서 같이 고민해 보자.</p>
<p><strong><code>참고</code></strong> <code>logout()</code> 메소드/기능은 API 클라이언트에서는 필요하지 않다. 정당한 사용자로 부터의 API 요청인지를 서버 사이드에서 인증하는 방법으로 Oauth 또는 JWT 를 주로 사용하는데, 두 방법 모두 token 을 HTTP 요청에 포함해서 보낸다. token 이 없으면 로그인 과정을 거치지 않은 것으로 간주되고, token 이 만료되면 역시 로그인하지 않은 것으로 간주되므로 로그아웃이 필요하지 않다는 의미이다. 물론, <code>logout()</code> 기능을 제공하고, 정해진 토큰 만료 시간 이전에 토근을 강제로 삭제하거나 블랙리스트에 넣어 놓는 방법이 있기는 하지만, 필자 생각에 지금 당장은 필요성을 못 느끼겠다.  </p>
<h3>CSRF</h3>
<p>사용자 인증을 위해 JSON Web Token 을 사용할 것이다. 앞으로 곧 보겠지만, 모든 API 요청의 HTTP 헤더에는 <code>Authorization: Bearer {header.payload.signature}</code> 형태의 JWT 를 붙여서 보내야 하고, 이를 통해 사용자를 인식할 뿐 아니라, CSRF 와 같은 악의적인 공격으로 부터 방어할 것이다. 바꾸어 말하면 API 에서 CSRF 토큰 사용은 적절하지 않다는 말. 왜일까 잘 생각해 보면, API 에서는 HTML &quot;폼&quot;를 서버에서 클라이언트에 내려 주지 않기 때문에 서버에서 생성한 CSRF 토큰을 전달할 방법이 없다.</p>
<p>역시 <a href="13-restful-resource-controller.md">13강 - RESTful 리소스 컨트롤러</a> 에서, 특정 Route 에 대해서 글로벌 미들웨어로 등록된 CSRF 를, <code>$except = []</code> 속성을 이용해서 제외시키는 방법을 살펴본 바 있다. 그런데, 이번에는 조금 특수하다. 기존 Route 와 API Route 가 동일한 형태이기 때문이다. 가령 로그인의 경우 '<a href="http://myproject.dev:8000/auth/login">http://myproject.dev:8000/auth/login</a>', '<a href="http://api.myproject.dev:8000/auth/login">http://api.myproject.dev:8000/auth/login</a>' 으로 Route 에 정의된 'auth/login' Path 는 동일하기 때문이다. 둘 간에 서로 다른 부분은 도메인이라는 점에 착안해서, 필자는 아래 처럼 API 요청일 경우 CSRF 토큰 검사를 넘어가는 식으로 구현했다.</p>
<pre><code class="language-php">// app/Http/Middlewares/VerifyCsrfToken.php

class VerifyCsrfToken extends BaseVerifier
{
    public function handle($request, Closure $next)
    {
        if (is_api_request()) {
            return $next($request);
        }

        return parent::handle($request, $next);
    }
}</code></pre>
<!--@start-->
<hr />
<ul>
<li><a href="../readme.md">목록으로 돌아가기</a></li>
<li><a href="44-api-basic.md">44강 - API 기본기 및 기획</a></li>
<li><a href="46-jwt.md">46강 - JSON Web Token 을 이용한 인증</a>
<!--@end--></li>
</ul>

            <hr/>

            <nav id="pagination">
  <ul class="pager pager-bottom">
    <li class="previous ">
      <a href="/lessons/44-api-basic.html">
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_left</i>
        </span>
        <span class="pager-title">
          44강 - API 기본기 및...
        </span>
      </a>
    </li>
    <li class="next ">
      <a href="/lessons/46-jwt.html">
        <span class="pager-title">
          46강 - JWT 를 이용한...
        </span>
        <span class="pager-title-sm">
          <i class="material-icons">keyboard_arrow_right</i>
        </span>
      </a>
    </li>
  </ul>
</nav>                  </article>

        <hr class="divider">

        <div id="comment">
          <div class="comments" style="margin-bottom: 30px;">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//l5lessons.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  <!--script id="dsq-count-scr" src="//l5lessons.disqus.com/count.js" async></script-->
</div>        </div>
      </div>
    </div>
  </div>

  <div id="toggler">
    <a href="#" title="Open Menu">
      목록 토글
    </a>
  </div>

  <footer id="footer">
  <div>
    &copy; 2016 &nbsp; <a href="https://github.com/appkr">appkr</a> •
    Built with <a href="http://jigsaw.tighten.co/">Jigsaw</a> •
    Hosted by <a href="https://pages.github.com/">Github</a> •
    <a href="/feed.xml">Rss</a>
  </div>
</footer>

<div id="back-to-top">
  <a href="#" title="Scroll to Top">
    <i class="material-icons">keyboard_arrow_up</i>
  </a>
</div>
  <script src="/js/all.js"></script>
</body>
</html>
